/**
 * This file was automatically generated by the Mule Development Kit
 */
package com.coralcea.modules.jasper;

import java.io.File;
import java.io.FileInputStream;
import java.lang.reflect.Method;
import java.net.URI;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Map;
import java.util.TimeZone;
import java.util.UUID;

import javax.jms.Connection;
import javax.jms.DeliveryMode;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageConsumer;
import javax.jms.MessageListener;
import javax.jms.MessageProducer;
import javax.jms.ObjectMessage;
import javax.jms.Queue;
import javax.jms.Session;
import javax.jms.TextMessage;
import javax.jms.Topic;

import org.apache.activemq.ActiveMQConnectionFactory;
import org.apache.log4j.Logger;
import org.jasper.jLib.jAuth.ClientLicense;
import org.jasper.jLib.jAuth.util.JAuthHelper;
import org.jasper.jLib.jCommons.admin.JasperAdminMessage;
import org.jasper.jLib.jCommons.admin.JasperAdminMessage.Command;
import org.jasper.jLib.jCommons.admin.JasperAdminMessage.Type;
import org.mule.DefaultMuleEvent;
import org.mule.DefaultMuleMessage;
import org.mule.MessageExchangePattern;
import org.mule.api.ConnectionException;
import org.mule.api.ConnectionExceptionCode;
import org.mule.api.MuleContext;
import org.mule.api.MuleEvent;
import org.mule.api.MuleException;
import org.mule.api.MuleMessage;
import org.mule.api.annotations.Category;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.ConnectionIdentifier;
import org.mule.api.annotations.Connector;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.Source;
import org.mule.api.annotations.SourceThreadingModel;
import org.mule.api.annotations.ValidateConnection;
import org.mule.api.annotations.display.FriendlyName;
import org.mule.api.annotations.display.Placement;
import org.mule.api.annotations.display.Summary;
import org.mule.api.annotations.lifecycle.Start;
import org.mule.api.annotations.lifecycle.Stop;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.api.annotations.param.Payload;
import org.mule.api.callback.SourceCallback;
import org.mule.api.callback.StopSourceCallback;
import org.mule.api.config.MuleConfiguration;
import org.mule.api.config.MuleProperties;
import org.mule.api.construct.FlowConstruct;
import org.mule.api.context.MuleContextAware;
import org.mule.api.transport.ReplyToHandler;
import org.mule.session.DefaultMuleSession;

import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.ModelFactory;
import com.hp.hpl.jena.rdf.model.Statement;
import com.hp.hpl.jena.rdf.model.StmtIterator;

/**
 * Jasper Connector
 *
 * @author Coral CEA
 */
@Connector(name="jasper", schemaVersion="1.0", friendlyName="Jasper", minMuleVersion="3.4")
@Category(name = "org.mule.tooling.category.endpoints", description = "Endpoints")
public class JasperConnector implements MuleContextAware
{
    /**
     * The URL of Jasper
     */
    @Configurable
    @Optional @Default(value="tcp://0.0.0.0:61616")
    @Placement(tab="General", group="Connection", order=0)
    @FriendlyName(value="Jasper URL")
    @Summary(value="The URL of Jasper")
    private String url;

    /**
     * The vendor's name
     */
    @Configurable
    @Placement(tab="General", group="Connection", order=1)
    @FriendlyName(value="Vendor")
    @Summary(value="The vendor's name")
    private String vendor;

    /**
     * The application's name
     */
    @Configurable
	@Placement(tab="General", group="Connection", order=2)
    @FriendlyName(value="Application")
    @Summary(value="The application's name")
    private String application;

    /**
     * The application's version
     */
    @Configurable
    @Placement(tab="General", group="Connection", order=3)
    @FriendlyName(value="Version")
    @Summary(value="The application's version")
    private String version;

    /**
     * The application's deployment id
     */
    private String deploymentId;
    
    /**
     * The JMS connection to Jasper
     */
    private Connection connection;
    
    /**
     * Whether the connection is established
     */
    private boolean connected;

    /**
     * The error logger
     */
	protected Logger logger = Logger.getLogger(getClass());

	/**
	 * The topic publishers
	 */
	private HashMap<String, TopicPublisher> topicPublishers = new HashMap<String, TopicPublisher>();

	/**
	 * The topic subscribers
	 */
	private HashMap<String, TopicSubscriber> topicSubscribers = new HashMap<String, TopicSubscriber>();

	/**
	 * The queue receivers
	 */
	private HashMap<String, QueueReceiver> queueReceivers = new HashMap<String, QueueReceiver>();

	/**
	 * The global queue receiver
	 */
	private QueueReceiver globalReceiver;

	/**
	 * The global sender
	 */
	private QueueSender globalSender;
	
	/**
	 * The response sender
	 */
	private QueueSender responseSender;
	
	/**
	 * The received responses
	 */
	private Map<String,Message> responses = new HashMap<String, Message>();
	
	/**
	 * The sender locks
	 */
	private Map<String,Object> locks = new HashMap<String, Object>();

	/**
	 * The global queue name
	 */
	private String GLOBAL_QUEUE = "jms.jasper.delegate.global.queue";
	
	/**
	 * The admin queue prefix
	 */
    private static final String JTA_QUEUE_PREFIX = "jms.";

	/**
	 * The admin queue suffix
	 */
    private static final String JTA_QUEUE_SUFFIX = ".admin.queue";
    
    /**
     * Timeout for message producers
     */
    private static final int TIME_TO_LIVE = 30000;
    
	/**
	 * The mule context
	 */
	private MuleContext muleContext;
	
	/**
     * Set URL property
     *
     * @param url URL
     */
    public void setUrl(String url)
    {
        this.url = url;
    }

    /**
     * Get URL property
     * 
     * @return url
     */
    public String getUrl() {
		return url;
	}

    /**
     * Set Vendor property
     *
     * @param vendor Vendor
     */
    public void setVendor(String vendor)
    {
        this.vendor = vendor;
    }

    /**
     * Get Vendor property
     * 
     * @return vendor
     */
    public String getVendor() {
		return vendor;
	}

    /**
     * Set Application property
     *
     * @param application Application
     */
    public void setApplication(String application)
    {
        this.application = application;
    }

    /**
     * Get Application property
     * 
     * @return application
     */
    public String getApplication() {
		return application;
	}

    /**
     * Set Version property
     *
     * @param version Version
     */
    public void setVersion(String version)
    {
        this.version = version;
    }

    /**
     * Get Version property
     * 
     * @return version
     */
    public String getVersion() {
		return version;
	}
    
	@Override
	public void setMuleContext(MuleContext muleContext) {
		this.muleContext = muleContext;
	}    	

    /**
     * Establish a connection to Jasper
     * 
     * @throws ConnectionException
     */
    @Start
    public void connect() throws ConnectionException {
    	try {
	    	// validate the license
	    	ClientLicense license = getValidLicenseKey();
	    	if (license == null || licenseExpiresInDays(license, 0))
				throw new Exception("Invalid Jasper license key");
	    	
	    	// create the connection
			deploymentId = license.getDeploymentId();
			String username = vendor + ":" + application + ":" + version + ":" + deploymentId;
			String password = JAuthHelper.bytesToHex(license.getLicenseKey());
			ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("failover://("+url+")");
			connection = connectionFactory.createConnection(username, password);
			
			// create the admin handler
		    String queueName = JTA_QUEUE_PREFIX + vendor + "." + application + "." + version + "." + deploymentId + JTA_QUEUE_SUFFIX;
		    new AdminHandler(queueName);
	
			// start the connection
		    connection.start();
			connected = true;
	
			// Start the subscribers and receivers in case they were not started before 
			for(TopicSubscriber subscriber : topicSubscribers.values())
				subscriber.start();
			for(QueueReceiver receiver : queueReceivers.values())
				receiver.start();
    	} catch (Exception e) {
    		throw new ConnectionException(ConnectionExceptionCode.UNKNOWN, null, "Error establishing a Jasper connection", e);
    	}
    }

    /**
     * Tear down the connection to Jasper
     * 
     * @throws Exception
     */
    @Stop
    public void disconnect() {
    	try {
			connected = false;
	    	if (connection != null) {
		    	connection.close();
		    	connection = null;
	    	}
    	} catch (Exception e) {
    		logger.error(e.getMessage());
    	}
    }

    /**
     * Decides whether the connection is on
     * 
     * @return true if the connection is established; otherwise false
     */
    @ValidateConnection
    public boolean isConnected() {
    	return connected;
    }

    /**
     * Are we connected
     */
    @ConnectionIdentifier
    public String connectionId() {
    	if (connected)
    		return String.valueOf(connection.hashCode());
    	return null;
    }

    /**
     * Publish to Topic
     *
     * {@sample.xml ../../../doc/jasper-connector.xml.sample jasper:publish-to-topic}
     *
     * @param topic A given topic 
     * @param content Content to be published to the given topic
     * @return Content to be forwarded to the next processor
     * @throws Exception if any error occurs
     */
    @Processor(friendlyName="Publish to Topic")
    public String publishToTopic(@Placement(group="Configuration") String topic, 
    		                     @Payload String content) throws Exception
    {
    	TopicPublisher publisher = topicPublishers.get(topic);
     	if (publisher == null)
			topicPublishers.put(topic, publisher = new TopicPublisher(topic));
     	
		publisher.publish(createTextMessage(publisher.getSession(), content, null));
		
		return content;
    }

    /**
     * Send to Queue Receive Response
     *
     * {@sample.xml ../../../doc/jasper-connector.xml.sample jasper:send-to-queue-receive-response}
     *
     * @param content Content to be sent to the given queue
     * @return Response to be forwarded to the next processor
     * @throws Exception if any error occurs
     */
    @Processor(friendlyName="Send to Queue and Receive Response")
    public String sendToQueueReceiveResponse(@Payload String content) throws Exception
    {
    	if (globalReceiver == null)
			globalReceiver = new QueueReceiver("jasper." + System.nanoTime() + ".queue", null) {
				public void onMessage(Message msg) {
					try {
						if(msg.getJMSCorrelationID() == null){
							logger.warn("Jasper response message recieved with null JMSCorrelationID, ignoring message.");
							return;
						}
						responses.put(msg.getJMSCorrelationID(), msg);
						if (locks.containsKey(msg.getJMSCorrelationID())){
							responses.put(msg.getJMSCorrelationID(), msg);
							Object lock = locks.remove(msg.getJMSCorrelationID());
							synchronized (lock) {
								lock.notifyAll();
							}
						} else {
							logger.error("response with correlationID = " + msg.getJMSCorrelationID() + " recieved however no record of sending message with this ID, ignoring");
						}
					} catch (JMSException e) {
						logger.error("Exception when storing response recieved in onMessage",e);
					}
				}
			};

     	if (globalSender == null)
			globalSender = new QueueSender(GLOBAL_QUEUE);
     	
	    TextMessage message = createTextMessage(globalSender.getSession(), content, globalReceiver.getQueue());
        String correlationID = message.getJMSCorrelationID();
		Message responseMsg = null;
		Object lock = new Object();
		synchronized (lock) {
			locks.put(correlationID, lock);
			globalSender.send(message);
			lock.wait(10000);
		    responseMsg = responses.remove(correlationID);
		}
		
		if(responseMsg == null)
			throw new JMSException("Timeout waiting for response to JMSCorrelationID : " + correlationID);			
		else if (!(responseMsg instanceof TextMessage))
			throw new JMSException("Response was not a TextMessage for JMSCorrelationID : " + correlationID);			
		else
			return ((TextMessage) responseMsg).getText();
    }

    /**
     * Subscribe to Topic
     *
     * {@sample.xml ../../../doc/jasper-connector.xml.sample jasper:subscribe-to-topic}
     *
     * @param topic A given topic 
     * @param callback The message processor to forward messages received on the topic to
     * @throws Exception if any error occurs
    */
    @Source(friendlyName="Subscribe to Topic", exchangePattern=MessageExchangePattern.ONE_WAY, threadingModel=SourceThreadingModel.NONE)
    public StopSourceCallback subscribeToTopic(@Placement(group="Configuration") final String topic, 
    		                                   final SourceCallback callback) throws Exception
    {
    	final TopicSubscriber subscriber;
		topicSubscribers.put(topic, subscriber = new TopicSubscriber(topic, callback));
		
		return new StopSourceCallback() {
			public void stop() throws Exception {
				subscriber.stop();
			}
		};
    }

    /**
     * Receive from Queue Send Response
     *
     * {@sample.xml ../../../doc/jasper-connector.xml.sample jasper:receive-from-queue-send-response}
     *
     * @param queue A given queue 
     * @param callback The message processor to forward messages received on the queue to
     * @throws Exception if any error occurs
     */
    @Source(friendlyName="Receive from Queue and Send Response", exchangePattern=MessageExchangePattern.REQUEST_RESPONSE, threadingModel=SourceThreadingModel.NONE)
    public StopSourceCallback receiveFromQueueSendResponse(@Placement(group="Configuration") String queue,
    		                                               final SourceCallback callback) throws Exception
    {
    	final QueueReceiver receiver;
		queueReceivers.put(queue, receiver = new QueueReceiver(queue, callback));

		return new StopSourceCallback() {
			public void stop() throws Exception {
				receiver.stop();
			}
		};
    }

    /**
     * Creates a text message
     * 
     * @param content The content to put in the message
     * @param correlationID The correlation ID
     * @param reply The reply destination if any
     * @return A new text message
     * @throws JMSException
     */
    private TextMessage createTextMessage(Session session, String content, String correlationID, Destination reply) throws JMSException {
        TextMessage message = session.createTextMessage();
		message.setText(content);
		message.setJMSCorrelationID(correlationID);
		message.setJMSReplyTo(reply);
		return message;
    }

    /**
     * Creates a text message with a random correlation ID
     * 
     * @param content The content to put in the message
     * @param reply The reply destination if any
     * @return A new text message
     * @throws JMSException
     */
    private TextMessage createTextMessage(Session session, String content, Destination reply) throws JMSException {
    	return createTextMessage(session, content, UUID.randomUUID().toString(), reply);
    }
    
    /**
     * Gets a valid license key
     * 
     * @return a license key if valid one is found, otherwise null
     */
    private ClientLicense getValidLicenseKey() throws Exception {
		String file = System.getProperty("jta-keystore");
		file += "/" + vendor + "_" + application + "_" + version;
		file += JAuthHelper.CLIENT_LICENSE_FILE_SUFFIX;
		ClientLicense license = JAuthHelper.loadClientLicenseFromFile(file);
		
		if (license.getVendor().equals(vendor) && 
    		license.getAppName().equals(application) &&
    		license.getVersion().equals(version))
			return license;
    	return null;
    }

    /**
     * Determines if the license will expire after a given number of days
     * 
     * @param license The license
     * @param days The number of day till expiry
     * @return true if the license expires after given number of days; otherwise false
     */
    private boolean licenseExpiresInDays(ClientLicense license, int days) {
		if(license.getExpiry() == null){
			return false;
		}else{
			Calendar currentTime;
			currentTime = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
			currentTime.add(Calendar.DAY_OF_YEAR, days);
			return currentTime.after(license.getExpiry());
		}		
	}
    
    /**
     * Topic Publisher Class
     */
    private class TopicPublisher  {
    	private Session session;
    	private Topic topic;
    	private MessageProducer producer;
    	
    	public TopicPublisher(String name) throws Exception {
			session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
    		topic = session.createTopic(name);
    		producer = session.createProducer(topic);
    		producer.setDeliveryMode(DeliveryMode.PERSISTENT);
    		producer.setTimeToLive(TIME_TO_LIVE);
    	}
    	
    	public void publish(TextMessage message) throws Exception {
    		producer.send(message);
    	}
    	
    	public Session getSession() {
    		return session;
    	}
    }    	
	
    /**
     * Queue Sender Class
     */
    private class QueueSender  {
    	private Session session;
    	private Queue queue;
    	private MessageProducer producer;
    	
    	public QueueSender(String name) throws Exception {
			session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
    		if (name != null)
    			queue = session.createQueue(name);
    		producer = session.createProducer(queue);
    		producer.setDeliveryMode(DeliveryMode.PERSISTENT);
    		producer.setTimeToLive(TIME_TO_LIVE);
    	}
    	
    	public void send(Message message) throws Exception {
    		producer.send(message);
    	}

    	public void send(Queue sendTo, Message message) throws Exception {
    		producer.send(sendTo, message);
    	}

    	public Session getSession() {
    		return session;
    	}
    }    	

    /**
     * Topic Subscriber Class
     */
    private class TopicSubscriber implements MessageListener {
    	private String name;
    	private SourceCallback callback;
    	private Session session;
    	private Topic topic;
    	private MessageConsumer consumer;
    	private boolean started;
    	
    	public TopicSubscriber(String name, SourceCallback callback) throws Exception {
    		this.name = name;
    		this.callback = callback;
    		start();
    	}
 
    	public void start() throws Exception {
    		if (!started && isConnected()) {
    			session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
	       		topic = session.createTopic(name);
	    		consumer = session.createConsumer(topic);
	    		consumer.setMessageListener(this);
	    		started = true;
    		}
     	}
    	
    	public void stop() throws Exception {
    		if (started) {
	    		session.close();
	    		started = false;
    		}
    	}
    	
		public void onMessage(Message msg) {
			try {
				if(msg.getJMSCorrelationID() == null)
					throw new JMSException("Recieved a message from Jasper with null JMSCorrelationID");			
				else if (!(msg instanceof TextMessage))
					throw new JMSException("Received message from Jasper was not a TextMessage for JMSCorrelationID : " + msg.getJMSCorrelationID());			
				else	
					callback.process(((TextMessage) msg).getText());
			} catch (Exception e) {
				logger.error("Exception when storing response recieved in onMessage",e);
			}		
		}
    }    	

    /**
     * Queue Receiver Class
     */
    private class QueueReceiver implements MessageListener, ReplyToHandler {
    	private String name;
    	private SourceCallback callback;
    	private Session session;
    	private Queue queue;
    	private MessageConsumer consumer;
    	private boolean started;
   	
    	public QueueReceiver(String name, SourceCallback callback) throws Exception {
    		this.name = name;
    		this.callback = callback;
    		start();
    	}
    	
    	public void start() throws Exception {
    		if (!started && isConnected()) {
    			session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        		queue = session.createQueue(name);
	    		consumer = session.createConsumer(queue);
	    		consumer.setMessageListener(this);
	    		started = true;
    		}
     	}
    	
    	public void stop() throws Exception {
    		if (started) {
	    		session.close();
	    		started = false;
    		}
    	}
    	
    	public Queue getQueue() {
    		return queue;
    	}
    	
		public void onMessage(Message msg) {
			try {
				if(msg.getJMSCorrelationID() == null)
					throw new JMSException("Recieved a message from Jasper with null JMSCorrelationID");			
				else if (!(msg instanceof TextMessage))
					throw new JMSException("Received message from Jasper was not a TextMessage for JMSCorrelationID : " + msg.getJMSCorrelationID());			
				else {
					String receivedMsg = ((TextMessage) msg).getText();
					Queue replyTo = (Queue) msg.getJMSReplyTo();
					
					if (replyTo == null) {
						callback.process(receivedMsg);
					} else {
				        MuleMessage muleMessage = new DefaultMuleMessage(receivedMsg, muleContext);
				        muleMessage.setCorrelationId(msg.getJMSCorrelationID());
				        muleMessage.setReplyTo(replyTo);
				        callback.processEvent(createMuleEvent(muleMessage));
					}
				}
			} catch (Exception e) {
				logger.error("Exception when storing response recieved in onMessage",e);
			}		
		}
		
		private MuleEvent createMuleEvent(MuleMessage msg) throws Exception {
			MuleConfiguration config = muleContext.getConfiguration();
			URI uri = URI.create("none");
			// This is a hack for getting the flow construct since there is no other
			// supported way to get it in devkit
			Method m = callback.getClass().getMethod("getFlowConstruct");
			FlowConstruct flowConstruct = (m != null) ? (FlowConstruct) m.invoke(callback) : null;
			return new DefaultMuleEvent(msg, uri, uri.toString(),
					MessageExchangePattern.ONE_WAY,
					flowConstruct, new DefaultMuleSession(),
					config.getDefaultResponseTimeout(), null, null,
					config.getDefaultEncoding(), false, true, msg.getReplyTo(), this);
        }
		
		public void processReplyTo(MuleEvent event, MuleMessage msg, Object replyTo) throws MuleException {
			try {
		     	if (responseSender == null)
		     		responseSender = new QueueSender(null);
		     	responseSender.send((Queue)replyTo, createTextMessage(responseSender.getSession(), msg.getPayloadAsString(), msg.getCorrelationId(), null));
			} catch (Exception e) {
				logger.error("Exception when sending response to Jasper inbound endpoint",e);
			}
		}

    }
    
    /**
     * Admin Handler Class
     */
    private class AdminHandler implements MessageListener {
    	private Session session;

    	public AdminHandler(String name) throws Exception {
			session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
    		Queue queue = session.createQueue(name);
    		MessageConsumer consumer = session.createConsumer(queue);
    		consumer.setMessageListener(this);
    	}
    	
		public void onMessage(Message message) {
			try {
		        if (message instanceof ObjectMessage) {
		        	Object obj = ((ObjectMessage) message).getObject();
		        	if(obj instanceof JasperAdminMessage){
		        		JasperAdminMessage adminMessage = (JasperAdminMessage) obj;
						if (adminMessage.getType() == Type.ontologyManagement && adminMessage.getCommand() == Command.get_ontology) {
		        			String[][] triples = getOntologyFromFile();
		    		     	if (responseSender == null)
		    		     		responseSender = new QueueSender(null);
		        			Message response = responseSender.getSession().createObjectMessage(triples);
		        			response.setJMSCorrelationID(message.getJMSCorrelationID());
							responseSender.send((Queue)message.getJMSReplyTo(), response );
						} else {
							logger.warn("Received JasperAdminMessage that isn't supported, ignoring : " + obj);
						}
	                } else {
	                	logger.warn("Received ObjectMessage that wasn't a JasperAdminMessage, ignoring : " + obj);
	                }
		          } else {
	                	logger.warn("Received JMSMessage that wasn't an ObjectMessage, ignoring : " + message);
		          }
			} catch (Exception e) {
				logger.error("Exception when storing response recieved in onMessage",e);
			}		
		}
		
	    private String[][] getOntologyFromFile() {
			ArrayList<String[]> triples = new ArrayList<String[]>();
	    	try {
	    		File file = new File(muleContext.getRegistry().lookupObject(MuleProperties.APP_HOME_DIRECTORY_PROPERTY) + "/" + application + ".ttl");
	    		FileInputStream fis = new FileInputStream(file);
	    		Model model = ModelFactory.createDefaultModel();
	    		model.read(fis, null, "TTL");
	    		for (StmtIterator statements = model.listStatements(); statements.hasNext(); ) {
	    			Statement statement = statements.next();
	    			triples.add(new String[]{statement.getSubject().toString(),statement.getPredicate().toString(),statement.getObject().toString()});
	    		}    		
	    	}catch (Exception e){
	    		logger.error("exception loading ontology from ttl file",e);
	    	}
			return triples.toArray(new String[][]{});    	
	    }
    }

}
